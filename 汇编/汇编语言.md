## 基本知识

一个存储单元大小为8bit即1个字节。

## 0.debug使用

**t命令**

用于执行cs:ip当前指向的那条指令。（IP寄存器将自动改写。）

**p命令**

遇到程序返回语句 int 21H 时，要用P命令而不是T命令执行。

遇到loop循环语句时，使用P命令可以自动执行完整个loop（也就是执行到cx=0），而不用一步步执行

**d命令查看内存内容（从数据角度）**

D回车，查看默认地址的内容

D 段地址:偏移地址 回车，查看指定地址的内容，如 D 2000:0

段地址可以使用段寄存器名，如  D ds:0002

可以指定查看范围，D 段地址:起始偏移地址 结尾偏移地址 ，如 D 1000:0 f

**r命令 查看、修改寄存器的值**

查看CPU寄存器的内容：R 回车

（2）改变CPU寄存器的内容：例如将段寄存器DS的值改为2000H，R DS 回车， 2000 回车（输入目标值）

**E命令  用于改写内存内容（从数据角度）**
（1）E 段地址:起始偏移地址 数据 数据 数据 ...    ，用空格分隔数据，用回车来退出修改。

（2）用提问的方式一个字节一个字节地改写。E 段地址:偏移地址 回车，（屏幕显示原有数据）然后输入新数据，回车。

（3）用第一种方式还可以写入字符或字符串。注意定界符，字符如'a'，字符串如"Hello"。

**u命令，将内存中的机器指令翻译成汇编指令**

可以用来查询指令所占用的字节数

## 1.cpu概述

一个典型cpu由运算器、控制器、寄存器等组成。

cpu内部靠内部总线相连。

cpu通过外部总线实现cpu和主板其他器件相连（地址、控制、数据总线）。



8086有14个寄存器（所有寄存器都是16位的，可以存放2个字节，即一个字），通用的有8个：

ax, bx, cx, dx, si, di, sp, bp, ip, cs, ss, ds, es, psw

ax, bx,  cx, dx通常用来存放一般性数据，被称为通用寄存器。

8086上一代（8088）的cpu中寄存器都是8位，为保证兼容性，这4个寄存器可以分为2个独立的8位寄存器使用，ax可以分为ah和al，high和low，代表高位和低位。如果要兼容以前的系统，那么在用的时候，ah置为0，然后只用al即可。



16位结构的cpu的特征：运算器alu一次最多可以处理16位数据，通用寄存器最大宽度为16位，寄存器和运算器之间的通路是16位。



8086有20位地址（外部）总线，8086内部为16位结构，只能传送16位地址。

因此在读写内存时，cpu提供了两个16位地址，一个是段地址，另一个是偏移地址。两个地址通过内部总线进入地址加法器，地址加法器把这两个地址加工成一个20位地址。



地址加法器：物理地址 = 段地址 x 16 + 偏移地址（即段地址16位，左移了4位，偏移地址4位）



8086cpu有4个段寄存器：cs（code segment）、ds（data segment）、ss（stack segment）、es



cs和ip是8086中最关键的寄存器，用来指示cpu要读取指令的地址。

cs为代码段寄存器，ip为指令指针寄存器。



读取指令过程：

从cs:ip指向的内存单元读取指令，读取到的指令进入指令缓冲器

ip = ip + 读取的指令长度，从而能指向下一条指令

执行指令，然后转到第一步，重复执行



正常来说cs:ip会顺序执行，但也可以通过修改cs:ip的值来控制cpu执行的指令

同时修改cs、ip的内容，jmp 段地址：偏移地址：

jmp 2AE3:3

只修改ip内容，jmp 某一合法寄存器

jmp ax



可以将起始地址为16倍数，长度为n（n <= 64kb = 2^16）的一组连续地址当作代码段（或数据段）。起始地址为16倍数是因为段地址会向左移4位，长度最多为2^16，是因为偏移地址最多只有16位。



## 2.内存访问

mov指令可以完成以下传送功能：

1.将数据直接送入寄存器 mov ax, 2

2.将一个寄存器中的内容送入另一个寄存器中 mov ax, bx

3.将一个内存单元的内容送入一个寄存器 mov al, [0]（将0号单元移入al，因为内存单元都是8bit，al也是8bit）



当要读取10000H单元的内容时，可以用以下程序段进行：

mov bx, 1000H

mov ds, bx （不能直接mov ds, 1000H，硬件设计问题，8086cpu不支持直接将数据送入段寄存器，具体我也不知道）

mov al, [0]（这条指令执行时，会根据ds找到段地址，然后去内存中的偏移地址0，读取该内存单元）

(如果是字的传送，可以用mov ax, [0])



当要将数据送入内存则是：

mov bx, 1000H

mov ds, bx

mov [0], al



## 3.栈

为什么要有栈？

小甲鱼说：以前是为了记录函数的返回地址，所以他认为是有了函数的调用才有了栈。



8086cpu提供相关的指令以栈的方式访问内存空间（出栈入栈都是以字位单位进行的，所以一个栈段的最大寻址范围也是2^16=64kb）

push和pop



8086cpu中，有其中两个寄存器：

段寄存器ss 存放栈顶的段地址

寄存器sp 存放栈顶的偏移地址

任意时刻，ss:sp指向栈顶元素



例如

1.push ax 将寄存器ax中的数据送入栈中

sp = sp - 2

将ax中的内容送入ss:sp指向的内存单元，ss：sp指向新栈顶



2.pop ax 从栈顶取出数据送入ax



3.push [0]

会根据ds的段地址，加上偏移量0的内存位置的字压入栈中



4.pop [2]

也是根据ds的段地址，加上偏移量2的位置，把字送入该位置



当10000H-1000FH这段空间当作栈的时候，初始状态栈是空的话，SS=1000H，SP为多少？

当里面有一个元素时，例如push ax，那么ss=1000H，sp就为栈顶000EH，那么空栈就为sp = sp + 2 = 0010H。



像硬盘中就算发生格式化，其实只是指针的改变，实际没有做磁盘的清理，要使用这块空间下次做覆盖即可。



ss和sp只记录了栈顶，但如何保证入栈和出栈时，栈顶不会超出栈空间？

8086cpu不保证对栈的操作不会超界（如果再添加两个寄存器保存栈底的位置，或许可以，但是没有这么设计，可能觉得用这么多寄存器来保证栈的越界问题，太奢侈）



## 4.编写程序



汇编程序从写出到执行的过程：

编程->a.asm->编译->a.obj->连接->1.exe->加载->内存中的程序->运行



使用汇编语言编译程序（masm.exe）对源程序进行编译，产生目标文件（把伪指令和汇编编成机器码），再用连接程序（link.exe）对目标文件（们）进行连接（当源程序很大，可以将它分成多个源程序文件来编译，每个源程序编译成目标文件后，再用连接程序将它们连接到一起，比如说程序中调用了某个库的子程序，需要将这个库文件和该程序生成的目标文件连接到一起），生成可在操作系统中直接运行的可执行文件。



汇编程序例子：

assume cs:codesg（假设cs段寄存器和segment ... ends定义的段相关联）

codesg segment（xxx segment和xxx ends是一对）

​	mov ax, 11

​	add ax, bx

codesg ends

end（代表汇编程序的结束）



codesg放在segment前面，作为一个段的名称，这个段的名称最终会被编译、连接程序处理为一个段的段地址。





汇编源程序：

伪指令（编译器处理，比如说告诉计算机哪里是code，哪里是data这些代码）

汇编指令（有对应的机器码指令）



标号：

除了伪指令和汇编指令外，还有一些标号，比如codesg，比如说start标志程序的入口，cs:ip会指向这里，start并不是固定，可以是begin，可以是hongjue，只要在end后面加上begin和hongjue即可。



程序加载后，ds中存放着程序所在的内存段地址，偏移地址为0，所以程序所在内存地址为：ds:0。

这个内存区前256个字节存放的是psp，psp是dos用来和程序进行通信（dos和window10的区别？），256字节往后存放的是程序。

所以假设整个程序的内存地址为SA（segment address）：0000，那么psp的起始段地址为SA：0000，程序内容的其实段地址为：SA+10H：0000（10H是因为段地址要乘以10，即16x16 = 256）。



为什么程序可以被执行？

一个p2程序可以执行的前提是，必须要有一个正在运行的程序p1，将p2从可执行文件加载进内存，将cpu的控制权交给p2，p2才能运行。当p2运行完后，需要将cpu的控制权交还给p1，让p1继续运行，交还的这个过程称之为程序返回。

需要再程序的末尾添加返回的程序段：

mov ax, 4c00H

int 21H（第21号中断）



那么这个正在运行的程序p1是什么？

任何通用的操作系统都要提供一个shell程序，让用户使用这个程序来操作计算机系统。



p1将程序加载入内存后，如何是的程序得以运行？

p1设置cpu的cs:ip指向程序的第一条指令（标号处），即程序的入口，让程序可以运行。



程序运行结束后，返回到哪里？

返回到程序p1，cpu继续运行p1。





为什么程序所在的内存段地址是放在ds中？







## 5.[bx]和loop

在debug中mov ax, [0]是把地址[0 - 1]的数据送入ax中，但是在汇编编译器中会把mov ax, [0] 认为是 mov ax, 0。

所以可以使用mov bx, 0; mov ax, [bx]来实现读取数据，或者说使用mov ax, ds:[0]，或mov ax, ds:[bx]





## 6.使用多个段

dw含义：define word，定义字型数据。

dw定义的字型数据用逗号进行分隔。

db：define byte。



如果不使用多个段，把数据，栈，代码都放在一个段里，会很乱，并且每一个段的大小是由限制的，除此之外我们需要指定start，否则如果一开始定义了数据，那么做执行的时候就会把数据当作代码了。



定义多个段：

```assembly
assume cs:code, ds:data, ss:stack
data segment
  dw 0123h, 0456h.....
data ends

stack segment
  dw 0,0,0,0...
stack ends

code segment
  start: mov ax, stack
  mov ss, ax
  ...
code ends
```



但这不代表cs段寄存器指向了code块，不代表ds段寄存器指向了data块，这只是一种声明，如果需要让ds指向data块，需要：

```assembly
mov ax, data
mov ds, ax
```

## 7.灵活定位内存地址

add和or指令，即与运算和或运算。



mov ax, [bx + 200]可以写成：

mov ax, [200+bx]

mov ax, 200[bx]

mov ax, [bx].200



si和di是8086cpu中和bx功能相近的寄存器，但是si和di不能够分成2个8位寄存器来使用，以下是一些示例：

(1)mov si, 0

mov ax, [si] 

或者mov ax, [bx + si]都是可以的



所以目前有以下几种方式灵活的寻址(idata表示常量)：

[idata]直接定位一个内存单元

[bx]间接定位

[bx + idata]

[bx + si]

[bx + si + idata]



假设现在有多重循环，而cx又是loop指令默认的循环计数器，寄存器的数量又是有限的，该怎么办？

我们可以在内存中保存循环次数，但如果要保存的数据比较多，还得记住该数据保存在哪个内存单元，那因为循环是一层层嵌套的，我们可以用栈保存cx，拿两重循环循环举一个例子：

mov ax, stack

mov ss, ax

mov sp, 30

mov cx, 4

s: mov ax, bx

push cx

mov cx, 5

s1: mov ax, bx

loop s1

pop cx

loop s



## 8.数据处理的两个基本问题

数据处理的两个问题：数据在哪，数据多长



（1）数据在哪

只有4个寄存器可以做内存寻址，即在[]中：bx,si,di,bp

如果是mov ax, [bx]; mov ax, [0]，默认段地址寄存器是ds

如果是mov ax, [bp + si + 8]这种形式，默认段寄存器是ss



（2）数据多长

8086cpu可以处理两种尺寸的数据，byte和word。

1.通过寄存器名指明数据的尺寸：mov ax, 1; mov ds:[0], ax; 都是字操作，mov al, 1; mov ds:[0], al;是字节操作

2.没有寄存器名情况下，可以用操作符X ptr知名内存单元长度，X可以位word或byte。

word如:

mov word ptr ds:[0], 1

inc word ptr [bx]

byte如：

mov byte ptr ds:[0], 1

add byte ptr [bx], 2



（3）其他

push指令不需要指明，因为push指令只进行字操作





div指令

除数：有8位和16位两种，可以存放在寄存器或者内存单元中

被除数：默认放在ax或（dx+ax）中，如果除数是8位，则被除数是16位，默认被除数放在ax中，如果除数16位，被除数则为32位（我也不知道为啥有这种关系，可能是为了放商和余数？），被除数高16位放在dx中，低16位放在ax中

结果：如果除数8位，则al放商，ah放余数；如果除数16位，ax放商，dx放余数



比如说100001/100

100001大于65535，需要用dx和ax一起存放，先转为16进制：186A1H

mov dx, 1

mov ax, 86A1H

mov bx, 100

div bx



伪指令dd

db和dw分别是define byte, define word，而dd则是double word，4个字节，即2个字。



dup

dup是一个操作符，用来进行数据的重复

比如db 3 dup(0)，定义了3个字节，它们的值都是0，相当于db 0,0,0

db 3 dup(0, 1, 2)，定义了9个字节，相当于db 0,1,2,0,1,2,0,1,2



## 9.转移指令的原理

可以修改ip或者同时修改cs和ip的指令统称为转移指令

只修改ip称为段内转移，比如jmp ax

同时修改cs和ip，称为段间转移，比如jmp 1000:0



段内转移又分为：短转移和近转移

短转移ip修改范围：-128~127

近转移ip修改范围：-32768~32767



操作符offset

offset的功能是取得标号的偏移地址，如：

start:mov ax, offset start //相当于mov ax, 0

s:mov ax, offset s //相当于mov ax, 3

取得start和s标号的偏移地址，即代码段中的第一条指令和第二条指令起始位置



jmp short 标号（转到标号处执行指令，这个是段内短转移）

jmp near 标号（段内近转移）

为什么要short和near做区分呢？假设：

start: mov ax, 0

jmp short s

add ax, 1

s: inc ax

那么jmp之后，cpu是如何让cs:ip指向s呢？

还记得cs：ip是如何工作的吗？从cs：ip读取指令，读取的指令进入指令缓冲器；然后ip = ip + 指令长度，从而指向下一条指令；执行指令；重复上述过程

那么本质上，jmp short s，是告诉cpu，ip应该偏移多少（编译时算出），所以就涉及到是8位还是16位了，短转移是8位，近转移是16位



jmp far ptr 标号，实现的是段间转移，又称为远转移，如：

jmp far ptr s

db 256 dup(0)

s: add ax, 1

那么这里的jmp会告诉cpu标号s的cs和ip值是什么



jmp 16位寄存器，即ip=16位寄存器的值

jmp word ptr 内存单元地址（段内转移），如：

mov ax, 0123H

mov ds:[0], ax

jmp word ptr ds:[0]



jmp dword ptr 内存单元地址（段间转移），高地址的字位目的段地址，低地址的字是目的偏移地址，如：

mov ax, 0123H

mov ds:[0], ax

mov word ptr ds:[2], 0

jmp dword ptr ds:[0]

(dd和dword貌似是一个意思，gpt了下，说可以相互转换)



jcxz是有条件转移指令，所有有条件转移指令都是短转移，指令格式：jcxz 标号，含义是如果cx=0则转移到标号处执行

例如：

s: mov cx, 0

jcxz short ok

jmp short s

ok: mov ax, cx



loop指令为循环指令，所有的循环指令都是短转移

loop 标号相当于：cx--; if(cx != 0) jmp short 标号;



nop指令

是一个空指令，占一个字节，主要作用是做字节填充对其，以及精确延时和计时







## 10.call和ret指令

call和ret都是转移指令，它们都修改ip，或同时修改cs和ip，它们经常被共同用来实现子程序的设计。



ret指令用栈中的数据，修改ip的内容，从而实现近转移，相当于pop ip

retf指令用栈中的数据，修改cs和ip的内容，从而实现远转移，相当于pop ip; pop cs



call指令

call 标号(将当前ip压栈，然后转到标号处执行)，即相当于：push ip; jmp near ptr 标号

call指令不能实现短转移

call far ptr 标号（段间转移），即：push cs; push ip; jmp far ptr 标号



call 16位寄存器，相当于：

push ip

jmp 16位寄存器



call word ptr 内存单元地址，相当于：

push ip

jmp word ptr 内存单元地址



call dword ptr 内存单元地址，相当于：

push cs

push ip

jmp dword ptr 内存单元地址





mul指令

mul是乘法指令，两个相乘的数要么都是8位，要么都是16位。

如果是8位，一个默认放在al中，另一个放在8位寄存器或者内存字节单元中；如果是16位，一个默认在ax中，另一个放在16位寄存器或者内存字单元中。8位乘法的结果默认放在ax中，16位的话，高位默认在dx中，低位在ax中。

格式（reg=寄存器）：

mul reg

mul 内存单元

例如：

```assembly
计算100 * 10
mov al, 100
mov bl, 10
mul bl
结果ax = 1000(03e8h)

计算100 * 10000
mov ax, 100
mov bx, 10000
mul bx
结果ax=4240h，dx=000fh，f4240h = 1000000
```



## 11.标志寄存器

我们已经学习了13个寄存器：ax,bx,cx,dx,cs,ss,ds,es,si,di,bp,sp,ip



标志寄存器：

0：cf

2：pf

4：af

6：zf

7：sf

8：tf

9：if

10：df

11：of





标志寄存器是一种特殊的寄存器，它的作用：

1.用来存储相关指令的某些执行结果

2.用来为cpu执行相关指令提供行为依据

3.用来控制cpu的相关工作方式



8086cpu的标志寄存器有16位，其中存储的信息被称为程序状态字（psw）

标志寄存器每一位都有专门的含义，记录特定的信息

比如add，sub，mul，div，inc，or，and等大多数运算指令都会影响标志寄存器，但像mov，push，pop等传送指令的执行对标志寄存器没有影响。



第6位是zf标志，它记录相关指令执行后，结果是否为0，如果是0，则zf=1，否则zf=0，比如：

mov ax, 1

and ax, 0

则af=1



第2位是pf标志，奇偶标志位，它记录相关指令执行后，其结果的二进制位中1的个数是否位偶数，如果是偶数，则pf=1；为奇数，那么pf=0，比如：

mov al, 1

add al, 10

al = 0000 1011B

有3个1，所以pf=0



第7位是sf，符号标志位，它记录相关指令执行后，结果是否为负，如果是为负，sf=1，否则sf=0，比如：

mov al, 1000 0001B

add al, 1

结果al=1000 0010B

如果我们把add指令进行的运算当作无符号数的运算，那么add指令相当于129 + 1=130（1000 0010B），也可以将add指令进行的运算当作有符号数的运算，那么add指令相当于-127 + 1 = -126，不管我们如何看待，cpu在执行add等指令的时候，就已经包含了两种含义，sf标志就是cpu对有符号数运算结果的一种记录，它记录数据的正负，如果我们当作无符号数来运算，则sf的值没有意义。



第0位是cf，进位标志位，它记录了**无符号数**运算结果的最高有效位向更高位的进位值，或从更高位的借位值。

当两个数相加，有可能产生向更高位进位，例如98h+98h，这个进位值在8位数中无法保存，它的这个进位会记录在cf中

例如：

mov al, 98h

add al, al ;执行后al=30h, cf=1

add al, al ;执行后al=60h, cf=0

当两个数做减法的时候，有可能需要向更高位借位，比如97h-98h就相当于197h-98h：

mov al, 97h

sub al, 98h ;al=ffh, cf=1，cf记录了向更高位的借位值

sub al, al ;al=0,cf=0



第11位是of标志，对于**有符号数**如果计算溢出了，of=1，否则of=0。我理解这相当于发生了有符号数的进位。如果负数+负数=正数，或者正数+正数=负数，这很明显就是溢出，但是正数+负数就需要自己手算下了，看是否在区间内，等下。。。如果是正数+负数，好像一定是在区间内？



adc指令

adc是带进位加法指令，指令格式：adc 操作对象1，操作对象2

比如adc ax, bx实际为：ax = ax + bx + cf

为什么要提供这种指令呢？

当我们计算两个值的求和时，如果这两个值都是大于16位，那么在8086要怎么计算：

假设1ef000h+201000h，我们把1ef000h拆分到两个寄存器中

mov ax, 001eh

mov bx, 0f000h

然后我们从低位开始加

add bx, 1000h

这个时候cf会等于1，然后我们再进行高位相加

adc ax, 0020h

我们通过把计算分成两部进行，最终算出了这两个值相加



sbb指令

sbb指令是带借位减法指令，利用cf记录的借位值，指令格式：sbb 操作对象1，操作对象2

比如sbb ax, bx实际为：ax = ax - bx - cf

例如计算003e 1000h - 0020 2000h

mov bx, 1000h

mov ax 003eh

sub bx, 2000h

sbb ax, 0020h

因为bx-2000需要向更高位借位，cf会标1来记录这个清空，然后高位减法的时候就把cf减去。



cmp指令

cmp是比较指令，相当于一个减法指令，但是不保存结果，但会影响标志寄存器。

cmp指令格式：cmp 操作对象1, 操作对象2

例如：

mov ax, 8

mov bx, 3

cmp ax

执行后ax=8,bx=3,zf=0,pf=1,sf=0,cf=0,of=0

当sf=1，of=0，说明没有发生溢出，即ax < bx

当sf=1，of=1，说明发生了溢出，呈现的结果是负数，但实际上应该是ax > bx，以为溢出改变了符号位

其他两种情况以此类推



许多条件转移指令会根据标志位的不同进行转移：

| 指令 |     含义     | 检测的相关标志位 |
| :--: | :----------: | :--------------: |
|  je  |  等于则转移  |       zf=1       |
| jne  | 不等于则转移 |       zf=0       |
|  jb  |  低于则转移  |       cf=1       |
| jnb  | 不低于则转移 |       cf=0       |
|  ja  |  高于则转移  |    cf=0且zf=0    |
| jna  | 不高于则转移 |    cf=1且zf=1    |

j表示jump

e：表示equal

ne：表示not equal

b：表示below

nb：表示not below

a：表示above

na：表示not above



df标志和串传送指令

标志寄存器的第10位是df，方向标志位，在配合串处理指令中，控制si,di的增减

df=0，si和di递增

df=1，si和di递减

如其中一个串传送指令movsb，它的作用是进行下面两个操作（将内存单元的字节送入es:di，然后递增或者递减si和di的值1）:

1.mov es:[i], byte ptr ds:[si] ;8086不支持这样的指令，这里只是一个描述

2.

如果df=0，则inc si, inc di

如果df=1，则dec si, dec di



movsw则是将内存单元的字送入es：di然后递增或者递减si和di的值2。



movsb和movsw是串传送操作的一个步骤，一般movsb和movsw都配合rep使用

rep movsb相当于：

s: movsb

loop s

可见，rep的作用是根据cx的值，重复执行串传送指令

又因为movsb需要考虑si和di是递增还是递减，所以需要有相应的手段修改df的值

8086cpu通过下面两条指令对df进行设置：

cld指令：将df置为0

std指令：将df置为1



pushf和popf

pushf是将标志寄存器的值压栈

popf是从栈中弹出数据，送入标志寄存器中



debug中，标志位的表示

| 标志 | 值为1的标记 | 值为0的标记 |
| ---- | ----------- | ----------- |
| OF   | OV          | NV          |
| SF   | NG          | PL          |
| ZF   | ZR          | NZ          |
| PF   | PE          | PO          |
| CF   | CY          | NC          |
| DF   | DN          | UP          |



## 12.内中断

在执行完当前正在执行的指令后，可以检测到从cpu外部发送过来或内部产生的一种特殊信息，并可以立即对所接收到的信息进行处理，这种信息称之为：中断信息。

中断的意思是：cpu不再接着向下执行，而是转去区里这个特殊信息。



对于8086cpu来说，以下几种情况发送时，将产生相应的内中断：

1.除法错误，比如div指令产生的除法溢出，中断类型码：0

2.单步执行，中断类型码：1

3.执行int0指令，中断类型码：4

4.执行int指令，指令格式int n，n为中断类型码



cpu在收到终端信息后，需要执行中断程序，需要将cs:ip指向它的入口，那么cpu要怎么知道程序入口在哪呢？

中断类型码的作用就是用来定位中断处理程序，那么怎么定位它的段地址和偏移地址呢？

cpu用8位的中断类型码通过中断向量表找到对应的中断处理程序入口地址。

中断向量指的是中断处理程序的入口地址

中断向量表存放了256个中断源所对应的中断处理程序入口

可以通过中断类型码作为中断向量表的表项号，定位相应的表项



中断类型码x4 和 中断类型码x4+2分别对应的中断处理程序的入口地址（偏移和段地址）



中断向量表放在内存地址0处，从0000：0000-0000：03e8的1000个单元存放中断向量表

一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，这个入口包括段地址和偏移地址，所以一个表项占2个字

高地址字放段地址，低地址字放偏移地址。



在中断过程中，设置cs:ip之前，需要将原先的cs:ip值保存起来，当执行完中断程序后，再返回继续执行，具体（因为执行完中断程序后，还需要恢复cpu现场，即cpu中各寄存器的值，所以需要在修改标记寄存器之前，把寄存器的值都入栈保存）：

1获取中断类型码

2标志寄存器的值入栈（中断过程需要改变标志寄存器的值）

3设置标志寄存器的第8位tf和第9位if值位0

4cs入栈

5ip入栈

6从内存地址位中断类型码x4 和中断类型码x4 + 2的两个字单元读取ip和cs

## 13.int指令









## 14.端口

pc机中，cpu通过总线相连的有各种接口卡芯片，比如网卡，显卡，比如主板上的接口芯片，cpu通过他们对部分外设进行访问，这些芯片中都有一组可以由cpu读写的寄存器，我们将这些寄存器称之为端口，对它们进行统一编址，从而建立了统一的端口地址空间。



cpu可以直接读写3个地方的数据：

1.cpu内的寄存器

2.内存单元

3.端口



对端口读写不能用mov、push、pop等指令，对端口读写的指令只有两条：in和out，分别是读取数据和往端口写入端口。



in al, 60h ;从60h端口读入一个字节





shl和shr指令

shl和shr是逻辑移位指令，shl是逻辑左移指令，功能为：

1.将一个寄存器或者内存单元中的数据向左移位

2.将最后移出的一位写入cf中

3.最低为用0来补充



例如又如下指令：

mov al, 0100 1000b

shl al, 1 ;将al中的数据左移一位

执行后al = 1001 0000b, cf = 0

如果移动的位数大于1时，必须将移动位数放在cl中，例如：

mov al, 01010001b

mov cl, 3

shl al, cl

这个时候al=10001000b，移出的为：010，那么cf的值是等于最后一个移出的0



## 15.外中断

外设比如键盘等是将输入先送入外设接口芯片的寄存器，即端口，cpu向外设输出也是先送入端口，再由相关芯片送入外设。



pc系统中，外中断源一共有两类：

1.可屏蔽中断

之前讲到的内中断过程：获取中断类型码n；标志寄存器入栈，置if=0，tf=0；cs和ip入栈；ip和cs改为中断程序的地址

可屏蔽中断除了第一步之外，其他基本相同，可屏蔽中断的中断信息来自cpu外部，中断类型码是通过数据总线传入的，而内中断的中断类型码是在cpu中产生。



if置为0的原因是为了进入中断处理程序后，禁止其他的可屏蔽中断



当我们在中断程序中需要处理可屏蔽中断，可以用指令将if置为1，8086cpu提供的设置if指令如下：

sti：用于设置if=1

cli：用于设置if=0



2.不可屏蔽中断

不可屏蔽中断是cpu必须响应的外中断，当cpu检测到不可屏蔽终端信息时，则在执行完当前指令后，立即响应，引发中断过程，对于8086cpu来说，不可屏蔽中断的中断类型码固定为2，所以中断过程中不需要中断类型码：

1.标志寄存器入栈，if=0，tf=0

2.cs、ip入栈

3.ip=8，cs=0ah



几乎所有外设都是可屏蔽中断



## 16.直接定址表

```assembly
data segment
a dw 0
data ends
code segment
mov ax, a ;相当于mov ax, ds:[0]而不是mov ax, 0
; mov al b这样会产生编译错误，因为b是dw类型
code ends
```



在后面加有“ : ”的地址标号只能在代码段中使用，不能在其他段中使用

如果在代码段中想访问数据段中的标号，需要在一开始用伪指令assume，例如assume ds:data，否则编译器无法确定标号的段地址在哪一个寄存器中



seg操作符，取得某一个标号的段地址：

```assembly
data segment
    a db 1,2,3,4,5,6,7,8
    c dw seg a
data ends
```



## 17.使用bios进行键盘输入和磁盘读写







## 其他

resb命令

resb 10就是reserve byte，从现在地址空出10个字节，并且在空出位置自动填充0x00



org命令

org 0x7c00指明该程序的内存装载地址（起始地址）



寄存器16位

ax-----累加寄存器 accumulator

cx-----计数寄存器 counter

dx-----数据寄存器 data

bx-----基址寄存器 base

sp-----栈指针寄存器 stack pointer

bp-----基址指针寄存器 base pointer

si-----源变址寄存器 source index

di-----目的变址寄存器 destination index

ax，cx，dx，bx后面的x代表extend，因为以前cpu是8位

32位寄存器即在每个寄存器前加一个e，例如eax，edi，esp，e代表extend中的e

## 遗留问题

为什么8086内部是16位，外部地址总线却是20位？如果设置成一样就不需要地址加法器，也不需要段地址了。



通过cs:ip确定了要读取该内存地址上的指令，然后放到指令缓冲区中，交给执行控制器做执行，然后ip做自增，比如该指令是2字节那就自增2，指令是3字节那就自增3，但是一开始怎么知道到底是2个字节还是3个字节？

指令的长度是由CPU内部的指令解码器来确定的。这个解码器会根据指令的操作码（opcode）和操作数来判断指令的长度。所以，当CPU读取指令时，它会根据CS:IP指向的位置读取足够长度的字节，以确保包含完整的指令。然后，CPU解码这些字节，并执行相应的指令。因此，CPU不需要提前知道每个指令的长度，它会根据指令的内容动态地确定每个指令的长度，并从内存中读取适当长度的字节。



loop指令和cx搭配，cx保存要执行循环的次数，loop s会跳转到s:，并且做cx -= 1，判断cx是否大于0，大于0则继续循环，否则继续往下执行，loop代码示例：

mov cx, 12

s:	mov ....

   	mov ....

​       loop s



es：estra segment，附加段寄存器，可以当作段寄存器，当段寄存器不够用时，可以使用es，比如要把一个数组的数据拷贝到另一个数组上，如果不使用es，就需要设置ds等于数组a的段地址，然后偏移取值，再设置ds等于数组b段地址，赋值。用了es就能把ds和es跳出循环外。

```java
for(int i = 0; i < n; i++) {
    b[i] = a[i];
}

```





为什么div指令要求除数如果是8位，被除数需要是16位；除数16位，被除数要32位，这是为啥？





call指令为什么不能实现短转移？

