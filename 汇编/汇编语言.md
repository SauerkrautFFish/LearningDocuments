## 基本知识

一个存储单元大小为8bit即1个字节。



## debug使用

**t命令**

用于执行cs:ip当前指向的那条指令。（IP寄存器将自动改写。）

**p命令**

遇到程序返回语句 int 21H 时，要用P命令而不是T命令执行。

遇到loop循环语句时，使用P命令可以自动执行完整个loop（也就是执行到cx=0），而不用一步步执行

**d命令查看内存内容（从数据角度）**

D回车，查看默认地址的内容

D 段地址:偏移地址 回车，查看指定地址的内容，如 D 2000:0

段地址可以使用段寄存器名，如  D ds:0002

可以指定查看范围，D 段地址:起始偏移地址 结尾偏移地址 ，如 D 1000:0 f

**r命令 查看、修改寄存器的值**

查看CPU寄存器的内容：R 回车

（2）改变CPU寄存器的内容：例如将段寄存器DS的值改为2000H，R DS 回车， 2000 回车（输入目标值）

**E命令  用于改写内存内容（从数据角度）**
（1）E 段地址:起始偏移地址 数据 数据 数据 ...    ，用空格分隔数据，用回车来退出修改。

（2）用提问的方式一个字节一个字节地改写。E 段地址:偏移地址 回车，（屏幕显示原有数据）然后输入新数据，回车。

（3）用第一种方式还可以写入字符或字符串。注意定界符，字符如'a'，字符串如"Hello"。

**u命令，将内存中的机器指令翻译成汇编指令**

可以用来查询指令所占用的字节数

## cpu概述

一个典型cpu由运算器、控制器、寄存器等组成。

cpu内部靠内部总线相连。

cpu通过外部总线实现cpu和主板其他器件相连（地址、控制、数据总线）。



8086有14个寄存器（所有寄存器都是16位的，可以存放2个字节，即一个字），通用的有8个：

ax, bx, cx, dx, si, di, sp, bp, ip, cs, ss, ds, es, psw

ax, bx,  cx, dx通常用来存放一般性数据，被称为通用寄存器。

8086上一代（8088）的cpu中寄存器都是8位，为保证兼容性，这4个寄存器可以分为2个独立的8位寄存器使用，ax可以分为ah和al，high和low，代表高位和低位。如果要兼容以前的系统，那么在用的时候，ah置为0，然后只用al即可。



16位结构的cpu的特征：运算器alu一次最多可以处理16位数据，通用寄存器最大宽度为16位，寄存器和运算器之间的通路是16位。



8086有20位地址（外部）总线，8086内部为16位结构，只能传送16位地址。

因此在读写内存时，cpu提供了两个16位地址，一个是段地址，另一个是偏移地址。两个地址通过内部总线进入地址加法器，地址加法器把这两个地址加工成一个20位地址。



地址加法器：物理地址 = 段地址 x 16 + 偏移地址（即段地址16位，左移了4位，偏移地址4位）



8086cpu有4个段寄存器：cs（code segment）、ds（data segment）、ss（stack segment）、es



cs和ip是8086中最关键的寄存器，用来指示cpu要读取指令的地址。

cs为代码段寄存器，ip为指令指针寄存器。



读取指令过程：

从cs:ip指向的内存单元读取指令，读取到的指令进入指令缓冲器

ip = ip + 读取的指令长度，从而能指向下一条指令

执行指令，然后转到第一步，重复执行



正常来说cs:ip会顺序执行，但也可以通过修改cs:ip的值来控制cpu执行的指令

同时修改cs、ip的内容，jmp 段地址：偏移地址：

jmp 2AE3:3

只修改ip内容，jmp 某一合法寄存器

jmp ax



可以将起始地址为16倍数，长度为n（n <= 64kb = 2^16）的一组连续地址当作代码段（或数据段）。起始地址为16倍数是因为段地址会向左移4位，长度最多为2^16，是因为偏移地址最多只有16位。



## 内存访问

mov指令可以完成以下传送功能：

1.将数据直接送入寄存器 mov ax, 2

2.将一个寄存器中的内容送入另一个寄存器中 mov ax, bx

3.将一个内存单元的内容送入一个寄存器 mov al, [0]（将0号单元移入al，因为内存单元都是8bit，al也是8bit）



当要读取10000H单元的内容时，可以用以下程序段进行：

mov bx, 1000H

mov ds, bx （不能直接mov ds, 1000H，硬件设计问题，8086cpu不支持直接将数据送入段寄存器，具体我也不知道）

mov al, [0]（这条指令执行时，会根据ds找到段地址，然后去内存中的偏移地址0，读取该内存单元）

(如果是字的传送，可以用mov ax, [0])



当要将数据送入内存则是：

mov bx, 1000H

mov ds, bx

mov [0], al



## 栈

为什么要有栈？

小甲鱼说：以前是为了记录函数的返回地址，所以他认为是有了函数的调用才有了栈。



8086cpu提供相关的指令以栈的方式访问内存空间（出栈入栈都是以字位单位进行的，所以一个栈段的最大寻址范围也是2^16=64kb）

push和pop



8086cpu中，有其中两个寄存器：

段寄存器ss 存放栈顶的段地址

寄存器sp 存放栈顶的偏移地址

任意时刻，ss:sp指向栈顶元素



例如

1.push ax 将寄存器ax中的数据送入栈中

sp = sp - 2

将ax中的内容送入ss:sp指向的内存单元，ss：sp指向新栈顶



2.pop ax 从栈顶取出数据送入ax



3.push [0]

会根据ds的段地址，加上偏移量0的内存位置的字压入栈中



4.pop [2]

也是根据ds的段地址，加上偏移量2的位置，把字送入该位置



当10000H-1000FH这段空间当作栈的时候，初始状态栈是空的话，SS=1000H，SP为多少？

当里面有一个元素时，例如push ax，那么ss=1000H，sp就为栈顶000EH，那么空栈就为sp = sp + 2 = 0010H。



像硬盘中就算发生格式化，其实只是指针的改变，实际没有做磁盘的清理，要使用这块空间下次做覆盖即可。



ss和sp只记录了栈顶，但如何保证入栈和出栈时，栈顶不会超出栈空间？

8086cpu不保证对栈的操作不会超界（如果再添加两个寄存器保存栈底的位置，或许可以，但是没有这么设计，可能觉得用这么多寄存器来保证栈的越界问题，太奢侈）



## 编写程序



汇编程序从写出到执行的过程：

编程->a.asm->编译->a.obj->连接->1.exe->加载->内存中的程序->运行



使用汇编语言编译程序（masm.exe）对源程序进行编译，产生目标文件（把伪指令和汇编编成机器码），再用连接程序（link.exe）对目标文件（们）进行连接（当源程序很大，可以将它分成多个源程序文件来编译，每个源程序编译成目标文件后，再用连接程序将它们连接到一起，比如说程序中调用了某个库的子程序，需要将这个库文件和该程序生成的目标文件连接到一起），生成可在操作系统中直接运行的可执行文件。



汇编程序例子：

assume cs:codesg（假设cs段寄存器和segment ... ends定义的段相关联）

codesg segment（xxx segment和xxx ends是一对）

​	mov ax, 11

​	add ax, bx

codesg ends

end（代表汇编程序的结束）



codesg放在segment前面，作为一个段的名称，这个段的名称最终会被编译、连接程序处理为一个段的段地址。





汇编源程序：

伪指令（编译器处理，比如说告诉计算机哪里是code，哪里是data这些代码）

汇编指令（有对应的机器码指令）



标号：

除了伪指令和汇编指令外，还有一些标号，比如codesg，比如说start标志程序的入口，cs:ip会指向这里，start并不是固定，可以是begin，可以是hongjue，只要在end后面加上begin和hongjue即可。



程序加载后，ds中存放着程序所在的内存段地址，偏移地址为0，所以程序所在内存地址为：ds:0。

这个内存区前256个字节存放的是psp，psp是dos用来和程序进行通信（dos和window10的区别？），256字节往后存放的是程序。

所以假设整个程序的内存地址为SA（segment address）：0000，那么psp的起始段地址为SA：0000，程序内容的其实段地址为：SA+10H：0000（10H是因为段地址要乘以10，即16x16 = 256）。



为什么程序可以被执行？

一个p2程序可以执行的前提是，必须要有一个正在运行的程序p1，将p2从可执行文件加载进内存，将cpu的控制权交给p2，p2才能运行。当p2运行完后，需要将cpu的控制权交还给p1，让p1继续运行，交还的这个过程称之为程序返回。

需要再程序的末尾添加返回的程序段：

mov ax, 4c00H

int 21H（第21号中断）



那么这个正在运行的程序p1是什么？

任何通用的操作系统都要提供一个shell程序，让用户使用这个程序来操作计算机系统。



p1将程序加载入内存后，如何是的程序得以运行？

p1设置cpu的cs:ip指向程序的第一条指令（标号处），即程序的入口，让程序可以运行。



程序运行结束后，返回到哪里？

返回到程序p1，cpu继续运行p1。





为什么程序所在的内存段地址是放在ds中？







## [bx]和loop

在debug中mov ax, [0]是把地址[0 - 1]的数据送入ax中，但是在汇编编译器中会把mov ax, [0] 认为是 mov ax, 0。

所以可以使用mov bx, 0; mov ax, [bx]来实现读取数据，或者说使用mov ax, ds:[0]，或mov ax, ds:[bx]





## 使用多个段

dw含义：define word，定义字型数据。

dw定义的字型数据用逗号进行分隔。



## 遗留问题

为什么8086内部是16位，外部地址总线却是20位？如果设置成一样就不需要地址加法器，也不需要段地址了。



通过cs:ip确定了要读取该内存地址上的指令，然后放到指令缓冲区中，交给执行控制器做执行，然后ip做自增，比如该指令是2字节那就自增2，指令是3字节那就自增3，但是一开始怎么知道到底是2个字节还是3个字节？

指令的长度是由CPU内部的指令解码器来确定的。这个解码器会根据指令的操作码（opcode）和操作数来判断指令的长度。所以，当CPU读取指令时，它会根据CS:IP指向的位置读取足够长度的字节，以确保包含完整的指令。然后，CPU解码这些字节，并执行相应的指令。因此，CPU不需要提前知道每个指令的长度，它会根据指令的内容动态地确定每个指令的长度，并从内存中读取适当长度的字节。



loop指令和cx搭配，cx保存要执行循环的次数，loop s会跳转到s:，并且做cx -= 1，判断cx是否大于0，大于0则继续循环，否则继续往下执行，loop代码示例：

mov cx, 12

s:	mov ....

   	mov ....

​       loop s



es：estra segment，附加段寄存器，可以当作段寄存器，当段寄存器不够用时，可以使用es，比如要把一个数组的数据拷贝到另一个数组上，如果不使用es，就需要设置ds等于数组a的段地址，然后偏移取值，再设置ds等于数组b段地址，赋值。用了es就能把ds和es跳出循环外。

```java
for(int i = 0; i < n; i++) {
    b[i] = a[i];
}

```

